<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linked Lists</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>

    <h1 id="linked-lists">Linked Lists</h1>
    <a href="programming_data_structures_algorithms.html" class="back-link">Back to Programming, Data Structures, and Algorithms Topics</a>
    <p>A linked list is a linear data structure in which elements are stored in nodes, and each node points to the next node in the sequence. Unlike arrays, linked lists do not store elements in contiguous memory locations, making insertion and deletion operations more efficient.</p>
    
    <h2>Types of Linked Lists</h2>
    <ul>
        <li><strong>Singly Linked List:</strong> Each node points to the next node, and the last node points to null.</li>
        <li><strong>Doubly Linked List:</strong> Each node points to both the next and the previous nodes, allowing traversal in both directions.</li>
        <li><strong>Circular Linked List:</strong> The last node points back to the first node, forming a circular structure.</li>
    </ul>
    
    <h2>Basic Operations</h2>
    
    <h3>Insertion</h3>
    <p>Insertion can occur at the beginning, end, or at a specific position in the linked list.</p>
    <h4>Insertion at the Beginning</h4>
    <pre><code>class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

# Example usage
ll = LinkedList()
ll.insert_at_beginning(3)
ll.insert_at_beginning(2)
ll.insert_at_beginning(1)</code></pre>
    
    <h4>Insertion at the End</h4>
    <pre><code>def insert_at_end(self, data):
    new_node = Node(data)
    if not self.head:
        self.head = new_node
        return
    last_node = self.head
    while last_node.next:
        last_node = last_node.next
    last_node.next = new_node

# Example usage
ll.insert_at_end(4)
ll.insert_at_end(5)</code></pre>
    
    <h4>Insertion at a Specific Position</h4>
    <pre><code>def insert_at_position(self, data, position):
    new_node = Node(data)
    if position == 0:
        self.insert_at_beginning(data)
        return
    current_node = self.head
    for _ in range(position - 1):
        if not current_node.next:
            raise IndexError("Position out of bounds")
        current_node = current_node.next
    new_node.next = current_node.next
    current_node.next = new_node

# Example usage
ll.insert_at_position(1.5, 1)</code></pre>
    
    <h3>Deletion</h3>
    <p>Deletion can also occur at the beginning, end, or at a specific position in the linked list.</p>
    <h4>Deletion at the Beginning</h4>
    <pre><code>def delete_at_beginning(self):
    if not self.head:
        return
    self.head = self.head.next

# Example usage
ll.delete_at_beginning()</code></pre>
    
    <h4>Deletion at the End</h4>
    <pre><code>def delete_at_end(self):
    if not self.head:
        return
    if not self.head.next:
        self.head = None
        return
    second_last = self.head
    while second_last.next.next:
        second_last = second_last.next
    second_last.next = None

# Example usage
ll.delete_at_end()</code></pre>
    
    <h4>Deletion at a Specific Position</h4>
    <pre><code>def delete_at_position(self, position):
    if position == 0:
        self.delete_at_beginning()
        return
    current_node = self.head
    for _ in range(position - 1):
        if not current_node.next:
            raise IndexError("Position out of bounds")
        current_node = current_node.next
    if not current_node.next:
        raise IndexError("Position out of bounds")
    current_node.next = current_node.next.next

# Example usage
ll.delete_at_position(1)</code></pre>
    
    <h3>Traversal</h3>
    <p>Traversal involves visiting each node in the linked list to perform operations such as printing the elements.</p>
    <pre><code>def traverse(self):
    current_node = self.head
    while current_node:
        print(current_node.data, end=" -> ")
        current_node = current_node.next
    print("None")

# Example usage
ll.traverse()  # Output: 1 -> 1.5 -> 2 -> 3 -> 4 -> 5 -> None</code></pre>
    
    <h2>Applications</h2>
    <ul>
        <li><strong>Dynamic Memory Allocation:</strong> Linked lists provide efficient dynamic memory allocation.</li>
        <li><strong>Implementing Stacks and Queues:</strong> Linked lists are used to implement stacks and queues.</li>
        <li><strong>Graph Representation:</strong> Adjacency lists in graph representations use linked lists.</li>
        <li><strong>Polynomial Arithmetic:</strong> Linked lists are used to represent and manipulate polynomials.</li>
    </ul>
    
    <h2>Conclusion</h2>
    <p>Linked lists are versatile data structures that provide efficient insertion and deletion operations. Understanding the various types and operations of linked lists is essential for solving many computational problems.</p>
    
    <a href="programming_data_structures_algorithms.html" class="back-link">Back to Programming, Data Structures, and Algorithms Topics</a>

</body>
</html>
